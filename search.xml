<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F07%2F26%2Fvuex%2F</url>
    <content type="text"><![CDATA[一、vuex是什么专门为vue.js应用程序开发的状态管理模式 其三个层次分别代表： state 存放共享数据 view 视图 Actions 在view上用户的行为需要同步修改state中的共享数据，这里就是响应view上的用户输入导致的变化 在实际的操作中，会遇到如下情况： 多个视图依赖于同一状态来自不同视图的用户行为需要变更同一个状态。 这样，我们提出将组件的共享状态抽取出来，以全局单例模式进行管理。其数据响应机制如下图所示： 在这里需要知道的一个重点是： state:存放共享数据，组件可以共享使用这个数据。可以通过,mapState获取或者this.$store.state来获取，这里如果是多个数据需要获取，建议用mapState； mutations:可以改变state里的共享数据，写成方法的形式，组件中不可以直接调用，需要actions里的方法来调用； actions:调用mutations里的方法，在组件中，想要修改state的值，可以通过import mapActions。 二、vuex详细介绍下面详细介绍一下vuex的核心概念： State单一状态树就是存放一些数据，这些数据在很多组件中可能都需要。Vuex通过store选项，将该机制从根组件注入到每一个组件中，在store/index.js里需要调用Vue.use(Vuex)。 这样在每个组件中都可以获取store的方法有三种： 直接使用this.$store.state.count来获取 在组件中import store from ‘~common/store/‘，然后使用store.state.count来获取 import {mapState} from ‘~common/store/‘ ,组件里使用computed:mapState([‘aa’,’bb’]) 示例首先使用vuex时，新建一个store文件夹。在该文件夹里有一个index.js文件。 1234567891011121314151617//在main.js里引用import store from '~common/store/'//store/index.js里import Vue from 'vue'import Vuex from 'vuex'import actions from './actions'import mutations from './mutations'Vue.use(Vuex)const state = &#123; count&#125;export default new Vuex.Store(&#123; state, actions, mutations&#125;) Getter可以理解为对state里的数据进行一个计算得到新的值，这个值可能在多个组件中会经常用到，那我们就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，只有当它的依赖值发生改变才会重新计算。其可以通过不同的方式进行访问，具体可以看vue文档。 Mutation更改Vuex的store中的状态的唯一方法就是提交mutation每一个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。更改vuex的store中的状态就mutations中更改 示例1234567891011121314151617const ADD_ITEMNUM = 'ADD_ITEMNUM'const COMPUTE_SCORE = 'COMPUTE_SCORE'export default &#123; [ADD_ITEMNUM](state) &#123; if (state.itemNum &lt; state.itemDetail.length - 2) &#123; state.itemNum++ &#125; else if (state.itemNum &lt; state.itemDetail.length - 1)&#123; state.itemNum++ state.isShow = false &#125; &#125;, [COMPUTE_SCORE](state, chooseIndex) &#123; if (state.itemDetail[state.itemNum].topic_answer[chooseIndex].is_standard_answer === 1) &#123; state.score += 20 &#125; &#125;&#125; 调用mutations的函数，需要调用store.commit(‘increment’)1234567mutations: &#123; increment (state,n) &#123; // 变更状态 state.count++ &#125;&#125;store.commit('increment', 10) Mutation必须同步执行 ActionAction可以接受异步操作它提交的是mutation，它不直接更改状态。action函数内可以接受一个与store实例具有相同方法和属性的context对象，在这个action函数内可以通过调用context.commit来提交mutation，或者通过context.state和context.getters获取到state和getters的值 示例123456789//action.jsexport default &#123; addNum(&#123;commit, state&#125;) &#123; commit('ADD_ITEMNUM') &#125;, computeScore(&#123;commit, state&#125;, chooseIndex) &#123; commit('COMPUTE_SCORE', chooseIndex) &#125;&#125; 在Actions可以进行异步操作，在组件中调用actions里的方法，就可以使用this.$store.dispatch。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2018%2F07%2F13%2Fcomponent-communication%2F</url>
    <content type="text"><![CDATA[组件之间互相通信的方法 父组件向子组件传值 子组件向父组件传值 非父子组件通信 一、父组件向子组件传值 使用props属性进行传值 示例父组件 12345&lt;div id="c-box"&gt; 这是父容器 &lt;componentD :changeState="changeState"&gt;&lt;/componentD&gt; &lt;button @click="changeFn"&gt;点击子组件的state值从0开始重新累加&lt;/button&gt;&lt;/div&gt; 12345678910111213&lt;script&gt; import componentD from './d' export default &#123; components: &#123; componentD &#125;, data () &#123; return &#123; changeState: true &#125; &#125; &#125;&lt;/script&gt; 子组件 12345678910props: ['changeState']props: &#123; changeState: Boolean&#125;props: &#123; changeState: &#123; type: Boolean, default: [0,0,0] //这样可以指定默认的值 &#125;&#125; 注意使用props属性，父组件可以给子组件传值，但是子组件不可以修改父组件给子组件传的值。这里，子组件不可以修改changeState的值。这里需要通过子组件触发事件来通知父组件改变数据。 二、子组件向父组件传值 子组件内使用this.$emit(‘fn’, data) 示例这里做一个小demo，子组件的state的值从0开始累加。父组件有一个按钮，点击按钮子组件的state值从0开始重新累加. 父组件: 1234567&lt;template&gt; &lt;div id="c-box"&gt; 这是父容器 &lt;componentD :changeState="changeState" @changeNum="getChangeNum"&gt;&lt;/componentD&gt; &lt;button @click="changeFn"&gt;点击子组件的state值从0开始重新累加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; import componentD from './d' export default &#123; components: &#123; componentD &#125;, data () &#123; return &#123; changeState: true &#125; &#125;, methods: &#123; changeFn: function () &#123; this.changeState = false &#125;, getChangeNum: function (data) &#123; this.changeState = data &#125; &#125;, watch: &#123; changeState: function (cul, old) &#123; this.changeState = cul &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; #c-box &#123; width: 500px; height: 500px; border: 1px solid #ccc; position: relative; &#125;&lt;/style&gt; 子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div id="d-box"&gt; 这是子组件 &lt;span&gt;state:&lt;/span&gt;&lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; number: 0, timer: null, intervalFlag: true &#125; &#125;, props: &#123; changeState: Boolean &#125;, mounted: function () &#123; this.setIntervalFn() &#125;, methods: &#123; setIntervalFn: function () &#123; this.$emit('changeNum', true) this.timer = setInterval(() =&gt; &#123; this.number++ &#125;, 1000) &#125; &#125;, watch: &#123; number: function (cul, old) &#123; this.number = cul &#125;, changeState: function (cul, old) &#123; this.number = 0 clearInterval(this.timer) this.setIntervalFn() &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; #d-box &#123; width: 300px; height: 300px; border: 1px solid #ccc; position: absolute; left: 100px; top: 100px; &#125;&lt;/style&gt; 三、非父子组件传值 在根组件放空的vue实例，让所有的子组件都可以调用（这个作为一个中转站），对于不是父子组件的componentC和componentD。componentE调用事件触发(.$emit(‘fn’,123))，componentE调用事件接收（.$on(‘fn’,value =&gt; {})） 示例根组件 123456789101112new Vue(&#123; router, el: '#app', data: &#123; word: 'hello vue', Bus: new Vue() &#125;, components: &#123; 'my-header': myHeader &#125;, render: h =&gt; h(App)&#125;); componentC 1234&lt;button @click="submit"&gt;提交&lt;/button&gt;submit: function () &#123; this.$root.Bus.$emit('eventName', 123)&#125; componentE 12345created () &#123; this.$root.Bus.$on('eventName', value =&gt; &#123; console.log(value) &#125;)&#125;,]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
