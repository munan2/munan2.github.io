<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[移动端touch事件]]></title>
    <url>%2F2018%2F07%2F27%2Ftouch-event%2F</url>
    <content type="text"><![CDATA[我们在移动端开发时，会发现会遇到一个需求，就是手触摸手机屏幕进行滑动时，发生一系列事情，这里我来系统整理一下touch事件。 touch事件首先，touch事件包含三类事件： touchstart 手指触摸到指定dom元素上被触发 touchmove 手指在指定dom元素上滑动时被触发 touchend 手机离开指定的dom元素时被触发 touch属性下面是touch的属性截图： 通过这个图，我们可以看到其中有三个属性： changeTouches 涉及到当前事件的手指的列表 targetTouches 正在触摸指定dom的手指的列表 touches 正在触摸屏幕的所有手指的一个列表 这三个列表的差距非常的细微，首先其属性内部包含的东西都差不多，如图所示： 首先可以看出其是一个数组，现在我们详细介绍这里具体的属性的意思 clientX 触摸点距离可视区域的水平方向距离 clinetY 触摸点距离可视区域的垂直方向距离 screenX 触摸点到屏幕最左边的距离 screenY 触摸点到屏幕最上方的距离 pageX 触摸点到网页最上方的距离 pageY 触摸点到网页最左边的距离 force 触摸点压力 identifier 触摸点唯一标识 radiusX 触摸点椭圆的水平半径 radiusY 触摸点椭圆的垂直半径 rotationAngle 旋转角度 target 触摸目标 示例这里一个小demo，手触摸屏幕，屏幕上显示开始触摸的点的坐标以及水平方向和垂直方向移动的距离1234567891011121314151617181920212223242526&lt;div id="box"&gt; 请在移动端，PC上无法查看效果，滑动查看效果 &lt;div&gt;当前触摸点的横坐标是:&lt;span id="curDisX"&gt;&lt;/span&gt;，纵坐标是:&lt;span id="curDisY"&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;水平方向移动的距离是&lt;span id="moveDisX"&gt;&lt;/span&gt;，垂直方向移动的距离是：&lt;span id="moveDisY"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var oBox = document.querySelector('#box'); var oCurDisX = document.querySelector('#curDisX'); var oCurDisY = document.querySelector('#curDisY'); var oMoveDisX = document.querySelector('#moveDisX'); var oMoveDisY = document.querySelector('#moveDisY'); var currentX, currentY, moveX, moveY; document.addEventListener('touchstart', (e) =&gt; &#123; console.log(e.touches); currentX = e.touches[0].clientX; currentY = e.touches[0].clientY; oCurDisX.innerHTML = currentX; oCurDisY.innerHTML = currentY; &#125;) document.addEventListener('touchmove', (e) =&gt; &#123; moveX = e.touches[0].clientX - currentX; moveY = e.touches[0].clientY - currentY; oMoveDisX.innerHTML = moveX; oMoveDisY.innerHTML = moveY; &#125;)&lt;/script&gt; 注意事项在touchend事件中，touches和targetTouches的长度都为0，因为触摸离开时，没有触摸点了，注意前面对touches、targetTouches和changeTouches的定义 一个移动端轮播图收藏链接]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-animation]]></title>
    <url>%2F2018%2F07%2F26%2Fcss-animation%2F</url>
    <content type="text"><![CDATA[transition 过渡transition允许css属性值在一定时间内可以平滑地过渡。其主要包括四个属性值： transition-property 过渡效果的css属性名称 transiton-duration 过渡时间 transition-timing-function 过渡效果的速度曲线 可以取值 取值 描述 linear 平滑，相同的速度 ease 先慢后快再慢 ease-in 以慢速开始 ease-out 以慢速结束 ease-in-out 以慢速开始和结束的过渡效果 transition-delay 延迟时间 这里需要注意一下几点 transition需要事件触发，不可以在网页加载时自动发生transition是一次性的，不能重复发生，除非是一再触发 示例123456789101112&lt;style&gt; #box &#123; width: 40px; height: 40px; background-color: #f00; transition: width 2s ease .5s; &#125; #box:hover &#123; width: 100px; &#125;&lt;/style&gt;&lt;div id="box"&gt;&lt;/div&gt; animation 动画animation动画，其可以不需要事件触发就可以进行，其属性如下： animation-name 需要绑定到选择器的keyframe名称 animation-duration 动画持续时间 animation-timing-function 动画速度曲线，以什么样的速度进行变化，与transition的animation-timing-function一样 animation-delay 动画延迟时间 animation-iteration-count 播放次数，其取值可以是数字，或者infinite(无限次播放) animation-direction 是否应该轮流反向播放动画，默认取值normal，也可以取值alternate(反响播放动画) animation-play-state 规定动画是否正在运行或暂停 animation-fill-mode 固定动画时间之外状态 值 描述 none 不改变默认行为 forwards 保持最后一个属性值 backwards 应用开始属性值 both 根据animation-direction轮流应用forwards和backwards规则。 keyframe@keyframes，控制动画的中间环节，其主要必须需要的三个值是： 值 描述 animation-name 动画名称 keyframes-selector 动画市场的百分比，0-100% css-styles css样式属性 示例123456789101112131415161718192021&lt;style&gt; .box &#123; width: 50px; height: 50px; background-color: #f00; animation: change 2s ease 0.1s infinite; &#125; @keyframes change &#123; 50% &#123; width: 150px; height: 150px; opacity: 0.3; &#125; 100% &#123; width: 50px; height: 50px; opacity: 1; &#125; &#125;&lt;/style&gt;&lt;div class="box"&gt;&lt;/div&gt; transform 变形主要包括旋转(rotate)、扭曲(skew)、缩放(scale)、移动(translate)和矩阵变形(matrix)。其中比较常用的三种是rotate、scale和translate。 transform-origin 设置旋转元素的基点位置注意该属性必须和transform一起使用transform-origin:x-axis y-axis z-axis。其默认值是50% 50% 0。x-axis和y-axis的取值可以是left、center、right、length和%。z-axis的取值只能是length 1. 2d转换 translate(x,y) 平移 rotate(xdeg) 沿着顺时针旋转，允许负值 scale(x,y) 尺寸缩放 skew(x,y) 根据给定的水平线和垂直线进行给定角度的翻转 matrix() 把所有的2d转换方法结合在一起 2. 3d转换首先要弄清楚，在3d的方向怎么确定，哪个方向是x轴，哪个方向是y轴，哪个方向是z轴。这里可以通过下图看出。通过这个图，我们就可以确认rotateX、rotateY、rotateZ分别是按照哪个方向转换。结合3d转换的话，需要知道一个属性，perspective（视角） perspective定义3d元素距视角的距离，其值是number|none。其视点是浏览器正前方，就是我们眼睛看着电脑所在的方位。 perspective-origin 设置基点的位置perspective-origin: x-axis y-axis; 示例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .box &#123; width: 200px; height: 200px; background-color: #f00; opacity: 0.5; &#125; .aa:hover &#123; transition: transform 1s ease; transform: rotateZ(180deg); &#125; .bb:hover &#123; transform: rotateY(180deg); transition: transform 1s ease; &#125; .cc &#123; transform: rotateX(60deg); &#125; .dd &#123; transform: rotateY(60deg); &#125; .ee &#123; transform: rotateZ(60deg); &#125; .box-container &#123; margin: 100px; width: 200px; height: 200px; border: 1px solid #000; perspective: 600px; &#125;&lt;/style&gt;&lt;div class="box-container"&gt; &lt;div class="cc box"&gt;rolateX(45deg)&lt;/div&gt;&lt;/div&gt;&lt;div class="box-container"&gt; &lt;div class="dd box"&gt;rolateY(45deg)&lt;/div&gt;&lt;/div&gt;&lt;div class="box-container"&gt; &lt;div class="ee box"&gt;rolateZ(45deg)&lt;/div&gt;&lt;/div&gt; 不加perspective: 600px;其效果图如下左图，加上perspective: 600px;其效果图如右图：这里如果不加上perspective这个属性，你会发现图像还是平面的效果，但是加上这个属性给视点到浏览器一个视觉距离之后，会看到一个3d的效果。 3D效果注意有一个属性。transform-style: preserve-3d的属性设置，默认值为flat，即“素描作品”。这个属性的设置旨在告诉子元素需要遵循怎样的空间体系规则。这个属性不能继承，因此只要有子元素需要设置空间体系规则，就得在父元素声明这个属性。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期]]></title>
    <url>%2F2018%2F07%2F26%2Fvue-life-cycle%2F</url>
    <content type="text"><![CDATA[最近在整理一些知识点，就开始整理了有关于vue生命周期的一些东西。首先需要仔细观察一下vue的生命周期图：针对这个图，做整个vue生命周期的分析。 生命周期的过程 首先创建vue实例，然后初始化事件并监测数据。在created阶段之前就完成了数据的监测（这个阶段data和data的属性已存在，但是el未初始化） created函数触发后，开始初始化el，并且编译template。在created和beforeMount这两个阶段之间发生的事情比较多： 首先判断对象是否有el选项，有的话向下编译，没有的话，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。 template参数选项是否对生命周期有影响：(a) 如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。(b) 如果没有template选项，则将外部HTML作为模板编译。(c) 可以看到template中的模板优先级要高于outer HTML的优先级。 生命周期各阶段详述vue生命周期主要可以分为以下几个阶段： vue2.0 描述 beforeCreate 组建实例化刚被创建，该过程在组件属性计算之前，在这个时候data和el,以及自定义的message都是undefined created 组件实例化创建完成，属性已绑定，但是dom还未生成，$el属性还不存在,在这个时候data和message已经初始化了 beforeMount 模板编译/挂载之前 $el和data、message都被初始化了 mounted 模板编译/挂载之后 $el和data、message都被初始化了 beforeUpdate 组件更新之前 updated 组件更新之后 activated keep-alive,组件激活时被调用 deactivated keep-alive,组件移除时被调用 beforeDestory 组件销毁前被调用 destory 组件销毁后被调用 示例：通过这个例子，我们可以看出vue在各个钩子函数内干了什么123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue生命周期&lt;/title&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button v-on:click="change"&gt;点击改变值&lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; new Vue(&#123; el: '#app', data: &#123; message: 'hello' &#125;, methods: &#123; change: function () &#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;, beforeCreate: function () &#123; console.group('beforeCreate 创建前状态===============》'); console.log("%c%s", "color:red" , "el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //undefined console.log("%c%s", "color:red","message: " + this.message) &#125;, created: function () &#123; console.group('created 创建完毕状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group('beforeMount 挂载前状态===============》'); console.log("%c%s", "color:red","el : " + (this.$el)); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group('mounted 挂载结束状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, destroyed: function () &#123; console.group('destroyed 销毁完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; mounted和beforeMount这两种情况$el和data、message都被初始化了，但是其有一定的区别，beforeMount时应用虚拟Dom先把坑粘住了。mounted是挂载后的情况，在该阶段的时候，把值渲染进去。在beforeUpdate,可以监听到data的变化但是view层没有被重新渲染，view层的数据没有变化。等到updated的时候 view层才被重新渲染，数据更新。 如下图所示。 总结 beforeCreated：该状态在new Vue()之后，但这个阶段el,data，以及data内部的赋值都没有初始化。 created: 该状态数据已经被检测到了，data和data内部的值都可以取到，但是el还没有初始化 beforeMount:挂载前，这个时候el已经初始化了，但是dom结构内的使用data引用的值还没有被渲染 Mounted:挂载后，dom结构内的使用data引用的值已经被渲染]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F07%2F26%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex是什么专门为vue.js应用程序开发的状态管理模式 其三个层次分别代表： state 存放共享数据 view 视图 Actions 在view上用户的行为需要同步修改state中的共享数据，这里就是响应view上的用户输入导致的变化 在实际的操作中，会遇到如下情况： 多个视图依赖于同一状态来自不同视图的用户行为需要变更同一个状态。 这样，我们提出将组件的共享状态抽取出来，以全局单例模式进行管理。其数据响应机制如下图所示： 在这里需要知道的一个重点是： state:存放共享数据，组件可以共享使用这个数据。可以通过,mapState获取或者this.$store.state来获取，这里如果是多个数据需要获取，建议用mapState； mutations:可以改变state里的共享数据，写成方法的形式，组件中不可以直接调用，需要actions里的方法来调用； actions:调用mutations里的方法，在组件中，想要修改state的值，可以通过import mapActions。 vuex详细介绍下面详细介绍一下vuex的核心概念： State单一状态树就是存放一些数据，这些数据在很多组件中可能都需要。Vuex通过store选项，将该机制从根组件注入到每一个组件中，在store/index.js里需要调用Vue.use(Vuex)。 这样在每个组件中都可以获取store的方法有三种： 直接使用this.$store.state.count来获取 在组件中import store from ‘~common/store/‘，然后使用store.state.count来获取 import {mapState} from ‘~common/store/‘ ,组件里使用computed:mapState([‘aa’,’bb’]) 示例首先使用vuex时，新建一个store文件夹。在该文件夹里有一个index.js文件。 1234567891011121314151617//在main.js里引用import store from '~common/store/'//store/index.js里import Vue from 'vue'import Vuex from 'vuex'import actions from './actions'import mutations from './mutations'Vue.use(Vuex)const state = &#123; count&#125;export default new Vuex.Store(&#123; state, actions, mutations&#125;) Getter可以理解为对state里的数据进行一个计算得到新的值，这个值可能在多个组件中会经常用到，那我们就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，只有当它的依赖值发生改变才会重新计算。其可以通过不同的方式进行访问，具体可以看vue文档。 Mutation更改Vuex的store中的状态的唯一方法就是提交mutation每一个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。更改vuex的store中的状态就mutations中更改 示例1234567891011121314151617const ADD_ITEMNUM = 'ADD_ITEMNUM'const COMPUTE_SCORE = 'COMPUTE_SCORE'export default &#123; [ADD_ITEMNUM](state) &#123; if (state.itemNum &lt; state.itemDetail.length - 2) &#123; state.itemNum++ &#125; else if (state.itemNum &lt; state.itemDetail.length - 1)&#123; state.itemNum++ state.isShow = false &#125; &#125;, [COMPUTE_SCORE](state, chooseIndex) &#123; if (state.itemDetail[state.itemNum].topic_answer[chooseIndex].is_standard_answer === 1) &#123; state.score += 20 &#125; &#125;&#125; 调用mutations的函数，需要调用store.commit(‘increment’)1234567mutations: &#123; increment (state,n) &#123; // 变更状态 state.count++ &#125;&#125;store.commit('increment', 10) Mutation必须同步执行 ActionAction可以接受异步操作它提交的是mutation，它不直接更改状态。action函数内可以接受一个与store实例具有相同方法和属性的context对象，在这个action函数内可以通过调用context.commit来提交mutation，或者通过context.state和context.getters获取到state和getters的值 示例123456789//action.jsexport default &#123; addNum(&#123;commit, state&#125;) &#123; commit('ADD_ITEMNUM') &#125;, computeScore(&#123;commit, state&#125;, chooseIndex) &#123; commit('COMPUTE_SCORE', chooseIndex) &#125;&#125; 在Actions可以进行异步操作，在组件中调用actions里的方法，就可以使用this.$store.dispatch。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2018%2F07%2F13%2Fcomponent-communication%2F</url>
    <content type="text"><![CDATA[组件之间互相通信的方法 父组件向子组件传值 子组件向父组件传值 非父子组件通信 父组件向子组件传值 使用props属性进行传值 示例父组件 12345&lt;div id="c-box"&gt; 这是父容器 &lt;componentD :changeState="changeState"&gt;&lt;/componentD&gt; &lt;button @click="changeFn"&gt;点击子组件的state值从0开始重新累加&lt;/button&gt;&lt;/div&gt; 12345678910111213&lt;script&gt; import componentD from './d' export default &#123; components: &#123; componentD &#125;, data () &#123; return &#123; changeState: true &#125; &#125; &#125;&lt;/script&gt; 子组件 12345678910props: ['changeState']props: &#123; changeState: Boolean&#125;props: &#123; changeState: &#123; type: Boolean, default: [0,0,0] //这样可以指定默认的值 &#125;&#125; 注意使用props属性，父组件可以给子组件传值，但是子组件不可以修改父组件给子组件传的值。这里，子组件不可以修改changeState的值。这里需要通过子组件触发事件来通知父组件改变数据。 子组件向父组件传值 子组件内使用this.$emit(‘fn’, data) 示例这里做一个小demo，子组件的state的值从0开始累加。父组件有一个按钮，点击按钮子组件的state值从0开始重新累加. 父组件: 1234567&lt;template&gt; &lt;div id="c-box"&gt; 这是父容器 &lt;componentD :changeState="changeState" @changeNum="getChangeNum"&gt;&lt;/componentD&gt; &lt;button @click="changeFn"&gt;点击子组件的state值从0开始重新累加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; import componentD from './d' export default &#123; components: &#123; componentD &#125;, data () &#123; return &#123; changeState: true &#125; &#125;, methods: &#123; changeFn: function () &#123; this.changeState = false &#125;, getChangeNum: function (data) &#123; this.changeState = data &#125; &#125;, watch: &#123; changeState: function (cul, old) &#123; this.changeState = cul &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; #c-box &#123; width: 500px; height: 500px; border: 1px solid #ccc; position: relative; &#125;&lt;/style&gt; 子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div id="d-box"&gt; 这是子组件 &lt;span&gt;state:&lt;/span&gt;&lt;span&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; number: 0, timer: null, intervalFlag: true &#125; &#125;, props: &#123; changeState: Boolean &#125;, mounted: function () &#123; this.setIntervalFn() &#125;, methods: &#123; setIntervalFn: function () &#123; this.$emit('changeNum', true) this.timer = setInterval(() =&gt; &#123; this.number++ &#125;, 1000) &#125; &#125;, watch: &#123; number: function (cul, old) &#123; this.number = cul &#125;, changeState: function (cul, old) &#123; this.number = 0 clearInterval(this.timer) this.setIntervalFn() &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; #d-box &#123; width: 300px; height: 300px; border: 1px solid #ccc; position: absolute; left: 100px; top: 100px; &#125;&lt;/style&gt; 非父子组件传值 在根组件放空的vue实例，让所有的子组件都可以调用（这个作为一个中转站），对于不是父子组件的componentC和componentD。componentE调用事件触发(.$emit(‘fn’,123))，componentE调用事件接收（.$on(‘fn’,value =&gt; {})） 示例根组件 123456789101112new Vue(&#123; router, el: '#app', data: &#123; word: 'hello vue', Bus: new Vue() &#125;, components: &#123; 'my-header': myHeader &#125;, render: h =&gt; h(App)&#125;); componentC 1234&lt;button @click="submit"&gt;提交&lt;/button&gt;submit: function () &#123; this.$root.Bus.$emit('eventName', 123)&#125; componentE 12345created () &#123; this.$root.Bus.$on('eventName', value =&gt; &#123; console.log(value) &#125;)&#125;,]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
